# -*- coding: utf-8 -*-
"""Curso_Imersao_de_dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o82WrXaAlLnJLT-tiLBKWKSsY8jSziAb

## Aula 1

---



---
"""

import pandas as pd

font = "https://github.com/alura-cursos/imersao-dados-2-2020/blob/master/MICRODADOS_ENEM_2019_SAMPLE_43278.csv?raw=true"

data = pd.read_csv(font)
data.head() # head() mostra somente as 5 primeiras linhas.

data[['NU_IDADE', 'TP_SEXO']] # Data frame, uma parte dos dados.

data['SG_UF_RESIDENCIA'].unique() # printa somente os estados unicos em um array.

len(data['SG_UF_RESIDENCIA'].unique())

data['SG_UF_RESIDENCIA'].value_counts() # Conta quantas vezes apareceram cada elemento da coluna em ordem decrescente do valor.

data['NU_IDADE'].value_counts().sort_index()

data['NU_IDADE'].hist(bins = 82, figsize = (10,8)) # Gráfico dos dados; bins = caixinhas

data.query('IN_TREINEIRO == 1') # Somente printa os treineiros.

data.query('NU_IDADE == 13')['SG_UF_RESIDENCIA'] # Printa o estado dos 13 anos

exams = ['NU_NOTA_CN','NU_NOTA_CH','NU_NOTA_MT','NU_NOTA_LC','NU_NOTA_REDACAO']
data[exams].describe() # descreve as colunas

data['NU_NOTA_REDACAO'].quantile(0.99) # a nota do 1% melhor

data['NU_NOTA_REDACAO'].plot.box(grid = True, figsize = (10,8))

data[exams].boxplot(grid = True, figsize = (10,8))

"""Desafios

1- Proporção dos inscritos por idade
"""

data['NU_IDADE'].value_counts()*100/127380

"""2- Descobrir de quais estados são os inscritos com 13 anos."""

data.query('NU_IDADE == 13')['SG_UF_RESIDENCIA']

"""3- Adicionar título no gráfico"""

data['NU_IDADE'].value_counts().sort_index().plot.bar(figsize=(12, 10), title='Idades no ENEM')

"""4- Plotar os Histogramas das idades dos do treineiro e não treineiros."""

data.query('IN_TREINEIRO == 1')['NU_IDADE'].value_counts().sort_index().plot.bar(figsize = (10, 8), title="Treineiros")

data.query('IN_TREINEIRO == 0')['NU_IDADE'].value_counts().sort_index().plot.bar(figsize = (10, 8), title="Não Treineiros")

"""5- Comparar as distribuições das provas em inglês espanhol"""

print(len(data.query('TP_LINGUA == 0'))*100/127380, '% Inglês') # ING
print(len(data.query('TP_LINGUA == 1'))*100/127380, '% Espanhol') # ESP

"""##Aula 2

---



---
"""

data['TP_COR_RACA'].value_counts().sort_index()

data['TP_COR_RACA'].value_counts().sort_index().plot.pie(title = 'Cores no enem', figsize=(10,8), label = '', labels = ('Não definiu', 'Branco', 'Negro', 'Pardo', 'Amarelo', 'Indigena'), autopct='%1.1f%%')
# .pie = torta; label = titulo no lado; labels= lista dos 'branco, negro' que antes era 1,2,3; , autopct='%1.1f%%' coloca porcentagem de cada

import pandas as pd

font = "https://github.com/alura-cursos/imersao-dados-2-2020/blob/master/MICRODADOS_ENEM_2019_SAMPLE_43278.csv?raw=true"

dados = pd.read_csv(font)
dados.head() # head() mostra somente as 5 primeiras linhas.

import seaborn as sns
import matplotlib.pyplot as plt

renda = dados['Q006'].unique()
renda.sort()

plt.figure(figsize = (10, 8))
sns.boxplot(x = 'Q006', y = 'NU_NOTA_REDACAO', data = dados, order = renda)
plt.title("Nota\ de redação pela renda")

sns.displot(dados, x = "NU_NOTA_REDACAO")

provas = ["NU_NOTA_CN","NU_NOTA_CH","NU_NOTA_MT","NU_NOTA_LC","NU_NOTA_REDACAO"]
dados["NU_NOTA_TOTAL"] = dados[provas].sum(axis=1)
dados["NU_NOTA_TOTAL"].head()
notas_noZero = dados.query('NU_NOTA_TOTAL != 0')
print(notas_noZero)

plt.figure(figsize = (10, 8))
sns.boxplot(x = 'Q006', y = 'NU_NOTA_TOTAL', data = notas_noZero, order = renda)
plt.title("Notas de redação pela renda")

plt.figure(figsize = (10, 8))
sns.boxplot(x = 'Q006', y = 'NU_NOTA_TOTAL', data = notas_noZero, hue = "IN_TREINEIRO", order = renda) # hue coloca outra coluna comparativa
plt.title("Notas de redação pela renda")

"""Desafios

1- Criar uma função para plotar o boxplot do seaborn
"""

def boxplot_sea(x_axi, y_axi, db, ord, size, title):
  plt.figure(figsize = size)
  sns.boxplot(x = x_axi, y = y_axi, data = db, order = ord)
  plt.title(title)

boxplot_sea('Q006', 'NU_NOTA_MT', notas_noZero, renda, (10,8), "Nota total por renda no ENEM 2019")

"""2- Verificar se quem zerou a prova foi eliminado ou não estava presente"""

notas_zero = dados.query('NU_NOTA_TOTAL == 0')
presenca = ['TP_PRESENCA_CN', 'TP_PRESENCA_CH','TP_PRESENCA_LC','TP_PRESENCA_MT']
total_presenca = dados[presenca].sum(axis=1)
dados['TP_PRESENCA_TOTAL'] = total_presenca

N_foi = dados.query('TP_PRESENCA_TOTAL == 0')
E_foi = dados.query('TP_PRESENCA_TOTAL > 4')
# E_foi.query('NU_NOTA_TOTAL == 0') NGM Q Foi eliminado tirou 0

"""3- Quem é eliminado tira zero ou será NaN (não teve registro de notas)"""

# N

"""5- Fazer o mesmo boxplot olhando para a questão 25 (tem internet ou não) e fazer uma reflexão sobre o assunto e o contexto de pandemia."""

internet = notas_noZero['Q025'].unique()
label = {'A': 'Sem Acesso', 'B': 'Com Acesso'}

boxplot_sea('Q025', 'NU_NOTA_TOTAL', notas_noZero, internet, (10, 8), "Acesso a internet influencia na nota do ENEM?")

"""##Aula 3


---



---
"""

internet = notas_noZero['Q025'].unique()
legend = {'A': 'Sem Acesso', 'B': 'Com Acesso'}

plt.figure(figsize = (12,10))
sns.histplot(notas_noZero, x = 'NU_NOTA_TOTAL', bins = 1000, hue = "Q025", kde = True)
plt.gca().legend(('Não possui acesso a internet','Possui acesso a internet'))
plt.title("Notas totais do ENEM 2019 tirando 0")

plt.figure(figsize = (10, 10))
sns.scatterplot(data = notas_noZero, x = 'NU_NOTA_MT', y = 'NU_NOTA_LC')
plt.xlim((350, 1000))
plt.ylim((350, 800))

sns.pairplot(notas_noZero[provas])

correlacao = notas_noZero[provas].corr() #Semelhança de 0 a 1
correlacao

sns.heatmap(correlacao, annot = True)

"""Desafios

1- Filtrar as notas por seu estado ou sua cidade e refazer as análises, verificando se são semelhantes ao geral.
"""

me = notas_noZero.query('SG_UF_RESIDENCIA == "MG"')
sns.pairplot(me[provas])

"""## Aula 4"""

sem_Nan = notas_noZero[provas].dropna()

not_ent = sem_Nan[['NU_NOTA_LC','NU_NOTA_CN','NU_NOTA_CH','NU_NOTA_REDACAO']]
not_f = sem_Nan['NU_NOTA_MT']

SEED = 4321
x = not_ent
y = not_f

from sklearn.model_selection import train_test_split
x_treino, x_teste, y_treino, y_teste = train_test_split(x, y, test_size = 0.25, random_state=SEED)

from sklearn.svm import LinearSVR

modelo = LinearSVR(random_state=SEED)
modelo.fit(x_treino, y_treino) # Treinamento

mat_predict = modelo.predict(x_teste) # De acordo com as outras notas qual será a nota em matemática

y_teste

plt.figure(figsize = (10, 10))
sns.scatterplot(x = y_teste, y = ((y_teste - mat_predict)**2)**(1/2))

resultados = pd.DataFrame()
resultados["Real"] = y_teste
resultados["Previsões"] = mat_predict
resultados["Diferença"] = ((y_teste - mat_predict)**2)**(1/2)

resultados

resultados["Diferença"].mean()

from sklearn.dummy import DummyRegressor

modelo_d = DummyRegressor()
modelo_d.fit(x_treino, y_treino)
d_pred = modelo_d.predict(x_teste)

from sklearn.metrics import mean_squared_error

mean_squared_error(y_teste, d_pred)

"""Desáfios

1- Predict nota de CH, mais exato. Com dataframe.
"""

not_f = sem_Nan["NU_NOTA_CH"]
y = not_f
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.20, random_state = SEED)

modelo_CH = LinearSVR(random_state=SEED)
modelo_CH.fit(x_train, y_train)

CH_predict = modelo_CH.predict(x_test)
resultado = pd.DataFrame()
resultado["Real"] = y_test
resultado["Previsões"] = CH_predict
resultado["Diferença"] = ((y_test - CH_predict)**2)**(1/2)

resultado

plt.figure(figsize = (10, 10))
sns.scatterplot(x = y_test, y = ((y_test - CH_predict)**2)**(1/2))

"""2- Grafico pizza empregado doméstico no enem"""

la_pie = ("Não possui", "1 ou 2 dias por semana", "3 ou 4 dias por semana", "Pelo menos 5 dias por semana")
notas_noZero["Q007"].value_counts().sort_index().plot.pie(figsize=(10,8), title = "Empregados no ENEM 2019", labels = la_pie)

"""## Aula 5"""

from sklearn.svm import LinearSVR # Este modelo possui uma aleatoriedade significativa(prescisando do random_state)

x_treino, x_teste, y_treino, y_teste = train_test_split(x, y, test_size = 0.25, random_state=SEED)

modelo = LinearSVR(random_state=SEED)
modelo.fit(x_teste, y_teste)
mat_predict = modelo.predict(x_teste)
mean_squared_error(y_teste, mat_predict)

from sklearn.tree import DecisionTreeRegressor # Possui aleatoriedade muito baixa

mod_tree = DecisionTreeRegressor(max_depth = 3)
mod_tree.fit(x_treino, y_treino)
mat_pred_tree = mod_tree.predict(x_teste)
mean_squared_error(y_teste, mat_pred_tree)

from sklearn.model_selection import cross_validate

mod_tree = DecisionTreeRegressor(max_depth = 3)
result = cross_validate(mod_tree, x, y, scoring = "neg_mean_squared_error") # Tempo, e score
media = (result["test_score"]*-1).mean()

desvio_padrao = (result["test_score"]*-1).std() # Desvio da media
desvio_padrao

lim_s = media + (2*desvio_padrao)
lim_i = media - (2*desvio_padrao)

print(f"Intervalo de confiança {lim_s} - {lim_i}")

def calc_result(results):
  media = (result["test_score"]*-1).mean()
  desvio_padrao = (result["test_score"]*-1).std()
  lim_s = media + (2*desvio_padrao)
  lim_i = media - (2*desvio_padrao)
  print(f"Intervalo de confiança {lim_s} - {lim_i}")

from sklearn.model_selection import cross_validate
from sklearn.model_selection import KFold
import numpy as np

SEED = 1234
np.random.seed(SEED) # N precisa random state em cada

parts = KFold(n_splits = 10, shuffle=True)
mod_tree = DecisionTreeRegressor(max_depth = 3)
result = cross_validate(mod_tree, x, y, cv=parts, scoring = "neg_mean_squared_error") # Tempo, e score, cv é niveis de divisão
calc_result(result)

def tree_re(max_dep):
  parts = KFold(n_splits = 10, shuffle=True)
  mod_tree = DecisionTreeRegressor(max_depth = max_dep)
  result = cross_validate(mod_tree, x, y, cv=parts, scoring = "neg_mean_squared_error") # Tempo, e score, cv é niveis de divisão(n significa que mais niveis é melhor)
  # cvs d+ causa overfit, que é a decoração dos dados de treino e acaba piorando a maquian
  print((result["test_score"]*-1).mean())

tree_re(3)

for i in range(1,21):
  print(f"{i}:")
  tree_re(i)